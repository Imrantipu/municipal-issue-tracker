package com.issuetracker.domain.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * Issue domain model - represents a municipal issue reported by citizens.
 *
 * DESIGN PATTERN: Builder Pattern (Creational)
 * - Uses Lombok @Builder annotation to generate builder class at compile time
 * - Provides fluent API for object construction: Issue.builder().title("...").build()
 * - Why: Issue has 13 fields; builder is more readable than constructor with many parameters
 * - Benefits: Optional fields, immutability after build, method chaining
 *
 * DESIGN PATTERN: Domain Model Pattern (Domain-Driven Design)
 * - Issue is a rich domain object with business logic, not just a data container
 * - Encapsulates validation rules and state transition logic
 * - Enforces invariants (e.g., title length, status transitions)
 *
 * DESIGN PATTERN: Aggregate Root Pattern (Domain-Driven Design)
 * - Issue is an aggregate root that controls its own lifecycle
 * - All modifications go through Issue methods (not direct field access)
 * - Maintains consistency boundaries (e.g., assignedTo must be STAFF role)
 *
 * Usage Example:
 * <pre>
 * Issue issue = Issue.builder()
 *     .title("Broken streetlight on Main St")
 *     .description("The streetlight at 123 Main St has been out for 3 days...")
 *     .status(IssueStatus.OPEN)
 *     .priority(Priority.MEDIUM)
 *     .category(Category.INFRASTRUCTURE)
 *     .location("123 Main St, City Center")
 *     .reportedBy(citizenUser)
 *     .createdAt(LocalDateTime.now())
 *     .build();
 *
 * issue.validate();  // Throws exception if invalid
 * issue.assignTo(staffUser);  // Assign to staff member
 * issue.changeStatus(IssueStatus.IN_PROGRESS);  // Update status
 * </pre>
 *
 * Business Rules Enforced:
 * 1. Title must be 10-200 characters
 * 2. Description must be 20-2000 characters
 * 3. Location is required (max 500 characters)
 * 4. Status transitions must follow valid workflow
 * 5. Only STAFF/ADMIN can be assigned to issues
 * 6. Closed issues cannot be modified
 * 7. Soft delete (deletedAt timestamp, not physical deletion)
 */
@Data  // DESIGN PATTERN: Encapsulation - generates getters/setters with validation
@Builder  // DESIGN PATTERN: Builder Pattern - generates builder class
@NoArgsConstructor
@AllArgsConstructor
public class Issue {

    /**
     * Unique identifier for the issue.
     * Generated by database (auto-increment).
     */
    private Long id;

    /**
     * Short title summarizing the issue.
     * Constraints: 10-200 characters, required.
     * Example: "Broken streetlight on Main St"
     */
    private String title;

    /**
     * Detailed description of the issue.
     * Constraints: 20-2000 characters, required.
     * Should include: what, where, when, any additional context.
     */
    private String description;

    /**
     * Current status of the issue in its lifecycle.
     * Default: OPEN
     * Valid transitions enforced by canTransitionTo() method.
     */
    @Builder.Default
    private IssueStatus status = IssueStatus.OPEN;

    /**
     * Priority level indicating urgency.
     * Default: MEDIUM
     * Determines SLA for assignment and resolution.
     */
    @Builder.Default
    private Priority priority = Priority.MEDIUM;

    /**
     * Category classifying the type of issue.
     * Required. Determines which department handles the issue.
     */
    private Category category;

    /**
     * Physical location of the issue.
     * Constraints: Required, max 500 characters.
     * Example: "123 Main St, City Center" or "Corner of 5th Ave and Oak St"
     */
    private String location;

    /**
     * User who reported the issue.
     * Required. Can be CITIZEN, STAFF, or ADMIN.
     * Cannot be null.
     */
    private User reportedBy;

    /**
     * Staff member assigned to handle the issue.
     * Optional. Must be STAFF or ADMIN role when assigned.
     * Null if not yet assigned.
     */
    private User assignedTo;

    /**
     * Timestamp when the issue was created.
     * Set automatically when issue is first saved.
     */
    private LocalDateTime createdAt;

    /**
     * Timestamp when the issue was last updated.
     * Updated automatically on any modification.
     */
    private LocalDateTime updatedAt;

    /**
     * Timestamp when the issue was resolved.
     * Null if not yet resolved.
     * Set when status changes to RESOLVED.
     */
    private LocalDateTime resolvedAt;

    /**
     * Timestamp when the issue was closed.
     * Null if not yet closed.
     * Set when status changes to CLOSED.
     */
    private LocalDateTime closedAt;

    /**
     * Timestamp when the issue was soft-deleted.
     * Null if not deleted.
     * Soft delete for GDPR compliance and audit trail.
     */
    private LocalDateTime deletedAt;

    // ==================== VALIDATION METHODS ====================

    /**
     * Validates all issue fields according to business rules.
     * Throws IllegalArgumentException if any validation fails.
     *
     * @throws IllegalArgumentException if validation fails
     */
    public void validate() {
        validateTitle();
        validateDescription();
        validateLocation();
        validateCategory();
        validateReportedBy();
        validateStatus();
        validatePriority();
        validateAssignedUser();
    }

    /**
     * Validates the title field.
     *
     * Rules:
     * - Cannot be null or empty
     * - Must be between 10 and 200 characters after trimming
     *
     * @throws IllegalArgumentException if title is invalid
     */
    private void validateTitle() {
        if (title == null || title.trim().isEmpty()) {
            throw new IllegalArgumentException("Title cannot be empty");
        }

        String trimmedTitle = title.trim();
        if (trimmedTitle.length() < 10) {
            throw new IllegalArgumentException("Title must be at least 10 characters long");
        }
        if (trimmedTitle.length() > 200) {
            throw new IllegalArgumentException("Title cannot exceed 200 characters");
        }
    }

    /**
     * Validates the description field.
     *
     * Rules:
     * - Cannot be null or empty
     * - Must be between 20 and 2000 characters after trimming
     *
     * @throws IllegalArgumentException if description is invalid
     */
    private void validateDescription() {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Description cannot be empty");
        }

        String trimmedDescription = description.trim();
        if (trimmedDescription.length() < 20) {
            throw new IllegalArgumentException("Description must be at least 20 characters long");
        }
        if (trimmedDescription.length() > 2000) {
            throw new IllegalArgumentException("Description cannot exceed 2000 characters");
        }
    }

    /**
     * Validates the location field.
     *
     * Rules:
     * - Cannot be null or empty
     * - Cannot exceed 500 characters
     *
     * @throws IllegalArgumentException if location is invalid
     */
    private void validateLocation() {
        if (location == null || location.trim().isEmpty()) {
            throw new IllegalArgumentException("Location cannot be empty");
        }

        if (location.trim().length() > 500) {
            throw new IllegalArgumentException("Location cannot exceed 500 characters");
        }
    }

    /**
     * Validates the category field.
     *
     * @throws IllegalArgumentException if category is null
     */
    private void validateCategory() {
        if (category == null) {
            throw new IllegalArgumentException("Category cannot be null");
        }
    }

    /**
     * Validates the reportedBy field.
     *
     * @throws IllegalArgumentException if reportedBy is null
     */
    private void validateReportedBy() {
        if (reportedBy == null) {
            throw new IllegalArgumentException("ReportedBy user cannot be null");
        }
    }

    /**
     * Validates the status field.
     *
     * @throws IllegalArgumentException if status is null
     */
    private void validateStatus() {
        if (status == null) {
            throw new IllegalArgumentException("Status cannot be null");
        }
    }

    /**
     * Validates the priority field.
     *
     * @throws IllegalArgumentException if priority is null
     */
    private void validatePriority() {
        if (priority == null) {
            throw new IllegalArgumentException("Priority cannot be null");
        }
    }

    /**
     * Validates the assignedTo user.
     *
     * Rules:
     * - If assigned, user must have STAFF or ADMIN role
     *
     * @throws IllegalArgumentException if assigned user has invalid role
     */
    private void validateAssignedUser() {
        if (assignedTo != null) {
            Role role = assignedTo.getRole();
            if (role != Role.STAFF && role != Role.ADMIN) {
                throw new IllegalArgumentException("Issues can only be assigned to STAFF or ADMIN users");
            }
        }
    }

    // ==================== BUSINESS LOGIC METHODS ====================

    /**
     * Assigns this issue to a staff member.
     *
     * Business Rules:
     * - User must be STAFF or ADMIN role
     * - Cannot assign to CITIZEN
     * - Issue cannot be closed
     *
     * @param user the staff member to assign to
     * @throws IllegalArgumentException if user is null or has invalid role
     * @throws IllegalStateException if issue is closed or deleted
     */
    public void assignTo(User user) {
        if (user == null) {
            throw new IllegalArgumentException("Cannot assign to null user");
        }

        if (isDeleted()) {
            throw new IllegalStateException("Cannot assign deleted issue");
        }

        if (isClosed()) {
            throw new IllegalStateException("Cannot assign closed issue");
        }

        Role role = user.getRole();
        if (role != Role.STAFF && role != Role.ADMIN) {
            throw new IllegalArgumentException("Issues can only be assigned to STAFF or ADMIN users");
        }

        this.assignedTo = user;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Unassigns the current staff member from this issue.
     *
     * @throws IllegalStateException if issue is closed or deleted
     */
    public void unassign() {
        if (isDeleted()) {
            throw new IllegalStateException("Cannot unassign deleted issue");
        }

        if (isClosed()) {
            throw new IllegalStateException("Cannot unassign closed issue");
        }

        this.assignedTo = null;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Changes the status of this issue.
     *
     * Business Rules:
     * - Must follow valid status transition rules (defined in IssueStatus)
     * - Closed issues cannot have status changed
     * - Changing to RESOLVED sets resolvedAt timestamp
     * - Changing to CLOSED sets closedAt timestamp
     *
     * @param newStatus the new status
     * @throws IllegalArgumentException if transition is not allowed
     * @throws IllegalStateException if issue is deleted
     */
    public void changeStatus(IssueStatus newStatus) {
        if (newStatus == null) {
            throw new IllegalArgumentException("Status cannot be null");
        }

        if (isDeleted()) {
            throw new IllegalStateException("Cannot change status of deleted issue");
        }

        if (status == newStatus) {
            return; // No change needed
        }

        if (!status.canTransitionTo(newStatus)) {
            throw new IllegalArgumentException(
                    String.format("Invalid status transition from %s to %s", status, newStatus)
            );
        }

        this.status = newStatus;
        this.updatedAt = LocalDateTime.now();

        // Set timestamps based on new status
        if (newStatus == IssueStatus.RESOLVED) {
            this.resolvedAt = LocalDateTime.now();
        } else if (newStatus == IssueStatus.CLOSED) {
            this.closedAt = LocalDateTime.now();
        }
    }

    /**
     * Changes the priority of this issue.
     *
     * @param newPriority the new priority
     * @throws IllegalArgumentException if priority is null
     * @throws IllegalStateException if issue is closed or deleted
     */
    public void changePriority(Priority newPriority) {
        if (newPriority == null) {
            throw new IllegalArgumentException("Priority cannot be null");
        }

        if (isDeleted()) {
            throw new IllegalStateException("Cannot change priority of deleted issue");
        }

        if (isClosed()) {
            throw new IllegalStateException("Cannot change priority of closed issue");
        }

        this.priority = newPriority;
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Updates the title and description of this issue.
     *
     * Business Rules:
     * - Title and description must pass validation
     * - Cannot update closed or deleted issues
     *
     * @param newTitle the new title
     * @param newDescription the new description
     * @throws IllegalArgumentException if validation fails
     * @throws IllegalStateException if issue is closed or deleted
     */
    public void updateDetails(String newTitle, String newDescription) {
        if (isDeleted()) {
            throw new IllegalStateException("Cannot update deleted issue");
        }

        if (isClosed()) {
            throw new IllegalStateException("Cannot update closed issue");
        }

        // Temporarily set new values for validation
        String oldTitle = this.title;
        String oldDescription = this.description;

        try {
            this.title = newTitle;
            this.description = newDescription;
            validateTitle();
            validateDescription();
            this.updatedAt = LocalDateTime.now();
        } catch (IllegalArgumentException e) {
            // Restore old values if validation fails
            this.title = oldTitle;
            this.description = oldDescription;
            throw e;
        }
    }

    /**
     * Soft deletes this issue by setting deletedAt timestamp.
     *
     * Business Rules:
     * - Soft delete (not physical deletion) for audit trail and GDPR compliance
     * - Deleted issues can be restored by setting deletedAt to null
     *
     * @throws IllegalStateException if already deleted
     */
    public void softDelete() {
        if (isDeleted()) {
            throw new IllegalStateException("Issue is already deleted");
        }

        this.deletedAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    /**
     * Restores a soft-deleted issue.
     *
     * @throws IllegalStateException if issue is not deleted
     */
    public void restore() {
        if (!isDeleted()) {
            throw new IllegalStateException("Issue is not deleted");
        }

        this.deletedAt = null;
        this.updatedAt = LocalDateTime.now();
    }

    // ==================== QUERY METHODS ====================

    /**
     * Checks if this issue is deleted (soft delete).
     *
     * @return true if deleted, false otherwise
     */
    public boolean isDeleted() {
        return deletedAt != null;
    }

    /**
     * Checks if this issue is closed.
     *
     * @return true if status is CLOSED, false otherwise
     */
    public boolean isClosed() {
        return status == IssueStatus.CLOSED;
    }

    /**
     * Checks if this issue is resolved.
     *
     * @return true if status is RESOLVED, false otherwise
     */
    public boolean isResolved() {
        return status == IssueStatus.RESOLVED;
    }

    /**
     * Checks if this issue is currently assigned to a staff member.
     *
     * @return true if assigned, false otherwise
     */
    public boolean isAssigned() {
        return assignedTo != null;
    }

    /**
     * Checks if this issue is assigned to a specific user.
     *
     * @param user the user to check
     * @return true if assigned to the user, false otherwise
     */
    public boolean isAssignedTo(User user) {
        if (user == null || assignedTo == null) {
            return false;
        }
        return assignedTo.getId().equals(user.getId());
    }

    /**
     * Checks if this issue was reported by a specific user.
     *
     * @param user the user to check
     * @return true if reported by the user, false otherwise
     */
    public boolean isReportedBy(User user) {
        if (user == null || reportedBy == null) {
            return false;
        }
        return reportedBy.getId().equals(user.getId());
    }

    /**
     * Checks if this issue is overdue based on priority SLA.
     *
     * Overdue conditions:
     * - If not assigned: created more than assignmentSlaHours ago
     * - If assigned but not resolved: assigned more than resolutionSlaHours ago
     *
     * @return true if overdue, false otherwise
     */
    public boolean isOverdue() {
        if (isClosed() || isResolved()) {
            return false; // Resolved/closed issues are not overdue
        }

        LocalDateTime now = LocalDateTime.now();

        if (!isAssigned()) {
            // Check assignment SLA
            LocalDateTime assignmentDeadline = createdAt.plusHours(priority.getAssignmentSlaHours());
            return now.isAfter(assignmentDeadline);
        } else {
            // Check resolution SLA (from assignment time or status change to IN_PROGRESS)
            LocalDateTime resolutionDeadline = updatedAt.plusHours(priority.getResolutionSlaHours());
            return now.isAfter(resolutionDeadline);
        }
    }

    /**
     * Gets the number of hours until this issue is overdue.
     * Returns negative number if already overdue.
     *
     * @return hours until overdue (negative if overdue)
     */
    public long getHoursUntilOverdue() {
        if (isClosed() || isResolved()) {
            return Long.MAX_VALUE; // Not applicable
        }

        LocalDateTime now = LocalDateTime.now();
        LocalDateTime deadline;

        if (!isAssigned()) {
            deadline = createdAt.plusHours(priority.getAssignmentSlaHours());
        } else {
            deadline = updatedAt.plusHours(priority.getResolutionSlaHours());
        }

        return java.time.Duration.between(now, deadline).toHours();
    }
}
